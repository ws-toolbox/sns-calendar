<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNS投稿カレンダー管理</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>📱</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>
</head>
<body class="bg-gradient-to-br from-purple-50 to-blue-50 min-h-screen">
    <div id="app" class="max-w-[1920px] mx-auto p-6"></div>

    <script>
        const CLIENT_ID = '417822818519-8imosvo7c9e2gem7cp0rse0vm8vrjlou.apps.googleusercontent.com';
        const SCOPES = 'https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/spreadsheets';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const FOLDER_NAME = 'SNS投稿管理';
        const SHARED_DRIVE_ID = '0AHJk3pS7tSEgUk9PVA';
        const TARGET_FOLDER_ID = '1I23qmcfZ_x8c15NtW54vjhKQb7waJi-E';
        const SPREADSHEET_ID = '1QOwpEbvttoE51vjBNy79IEwPEUqAPBWMXYTB9on_NIw';
        const VIDEO_FOLDER_ID = '1085XOWlyw--O2ITRwS2kum2dXKZ8s87c';
        const INSTAGRAM_APP_ID = '3688415181455366';
        const INSTAGRAM_APP_SECRET = '70c616003680a73af282234235c3b82d';
        const INSTAGRAM_ACCOUNT_ID = '17841404355630376';
        const INSTAGRAM_ACCESS_TOKEN = 'EAAQVzgup6V8BP3Y4hwDOVEm2hM0bORhqiZAJN6u4RQ169IfkJ1AoNtOVFK8JhpDsgyLKrvIqfi8F50OFGPUDnayrHbDDnSmZCgS51MV9hLWRjiJuyjIW9EjZCO3XFI4GtZCm5kZAj3I7PrY4BZCnbD1udd9vBcfyyrGgHh45nVyCLVAZBv0Dx5BXirqUW6PiI6YCVvKwFSjOECBs2gYwRVfyKIUjll4FJ7yUPZAsIqZCZB4q1ztwc0HHztqBZC6teB0pAZDZD';
        const APP_VERSION = '2025/01/22 13:30';

        let gapiInited = false;
        let gisInited = false;
        let tokenClient;
        let accessToken = null;
        let fileId = null;

        let state = {
            currentDate: new Date(),
            posts: {},
            selectedDate: null,
            editingPostId: null,
            viewMode: 'edit',
            isSignedIn: false,
            isSaving: false,
            folderId: null,
            lastUpdated: null,
            currentYear: new Date().getFullYear(),
            userName: null,
            formData: {title: '', platforms: [], text: '', images: [], checks: [], completedChecks: []}
        };

        async function findAndDownloadVideo(productNumber) {
            if (!state.isSignedIn || !productNumber) {
                showMessage('商品番号が入力されていません', 'error');
                return;
            }
        
            try {
                showMessage('動画を検索中...', 'success');
        
                // 動画ファイルを検索
                const response = await gapi.client.drive.files.list({
                    q: `name='${productNumber}.mp4' and '${VIDEO_FOLDER_ID}' in parents and trashed=false`,
                    fields: 'files(id, name, webContentLink)',
                    spaces: 'drive',
                    supportsAllDrives: true,
                    includeItemsFromAllDrives: true
                });
        
                if (response.result.files && response.result.files.length > 0) {
                    const fileId = response.result.files[0].id;
                    const downloadUrl = `https://drive.google.com/uc?export=download&id=${fileId}`;
                    
                    // ダウンロードを開始
                    window.open(downloadUrl, '_blank');
                    showMessage('動画のダウンロードを開始しました', 'success');
                } else {
                    showMessage(`動画ファイル「${productNumber}.mp4」が見つかりませんでした`, 'error');
                }
            } catch (error) {
                console.error('Instagram投稿エラー:', error);
                console.error('エラー詳細:', JSON.stringify(error, null, 2));
                if (error.result) {
                    console.error('API レスポンス:', error.result);
                }
                showMessage(`❌ Instagram投稿に失敗しました: ${error.message || error.toString() || 'Unknown error'}`, 'error');
            }
        }

        async function changeMonth(offset) {
            const oldYear = state.currentDate.getFullYear();
            state.currentDate.setMonth(state.currentDate.getMonth() + offset);
            const newYear = state.currentDate.getFullYear();
            
            // 年が変わった場合のみ再読み込み
            if (oldYear !== newYear && state.currentYear !== newYear) {
                state.currentYear = newYear;
                await loadYearData();
            }
            
            render();
        }
        
        function copyProductUrl(productNumber) {
            const url = `https://winds-score.com/products/${productNumber}`;
            copyToClipboard(url);
        }

        function getCurrentYearFileName() {
            const currentYear = new Date().getFullYear();
            return `sns_calendar_data_${currentYear}.json`;
        }

        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            await gapi.client.init({
                discoveryDocs: [
                    DISCOVERY_DOC,
                    'https://sheets.googleapis.com/$discovery/rest?version=v4'
                ]
            });
            gapiInited = true;
            maybeEnableButtons();
        }

        async function uploadMediaToDrive(file) {
            if (!state.isSignedIn) return null;
        
            try {
                const metadata = {
                    name: file.name,
                    parents: [VIDEO_FOLDER_ID] // 動画用のフォルダIDを定義
                };
        
                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', file);
        
                const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&supportsAllDrives=true', {
                    method: 'POST',
                    headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),
                    body: form
                });
        
                if (!response.ok) {
                    throw new Error(`アップロードに失敗: ${response.status}`);
                }
        
                const result = await response.json();
                return result.id; // アップロードしたファイルのID
            } catch (error) {
                console.error('メディアアップロードエラー:', error);
                showMessage('メディアのアップロードに失敗', 'error');
                return null;
            }
        }

        async function exportToSpreadsheet() {
            if (!state.isSignedIn) {
                showMessage('先にGoogle Driveに接続してください', 'error');
                return;
            }
        
            if (Object.keys(state.posts).length === 0) {
                showMessage('エクスポートするデータがありません', 'error');
                return;
            }
        
            try {
                showMessage('スプレッドシートに書き込み中...', 'success');
        
                // データを準備
                const headers = [['投稿日', 'タイトル', '商品番号', '動画埋込', '投稿先', '投稿テキスト', 'リンク先', '備考', 'チェック完了者', '最終更新日時']];
                const rows = [];
                
                Object.keys(state.posts).sort().forEach(date => {
                    state.posts[date].forEach(post => {
                        const platforms = (post.platforms || [post.platform]).map(p => {
                            const badges = {
                                x: '𝕏',
                                instagram: 'Instagram',
                                line: 'LINE',
                                stumaga: 'スタマガ',
                                youtube: 'YouTube'
                            };
                            return badges[p] || p;
                        }).join(', ');
                        
                        const checks = (post.checks || []).join(', ');
                        const links = (post.links || []).join('\n');
                        
                        rows.push([
                            date,
                            post.title || '無題',
                            post.productNumber || '',
                            post.embedProduct ? 'はい' : '',
                            platforms,
                            post.text || '',
                            links,
                            post.remarks || '',
                            checks,
                            new Date().toLocaleString('ja-JP')
                        ]);
                    });
                });
        
                // シートをクリアしてデータを書き込み
                await gapi.client.sheets.spreadsheets.values.clear({
                    spreadsheetId: SPREADSHEET_ID,
                    range: 'シート1!A1:Z'
                });
        
                await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId: SPREADSHEET_ID,
                    range: 'シート1!A1',
                    valueInputOption: 'RAW',
                    resource: {
                        values: [...headers, ...rows]
                    }
                });
        
                // ヘッダー行を太字にフォーマット
                await gapi.client.sheets.spreadsheets.batchUpdate({
                    spreadsheetId: SPREADSHEET_ID,
                    resource: {
                        requests: [{
                            repeatCell: {
                                range: {
                                    sheetId: 0,
                                    startRowIndex: 0,
                                    endRowIndex: 1
                                },
                                cell: {
                                    userEnteredFormat: {
                                        textFormat: {
                                            bold: true
                                        }
                                    }
                                },
                                fields: 'userEnteredFormat.textFormat.bold'
                            }
                        }]
                    }
                });
        
                // スプレッドシートを開く
                window.open(`https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}`, '_blank');
                showMessage('スプレッドシートに書き込みました！', 'success');
        
            } catch (error) {
                console.error('スプレッドシート書き込みエラー:', error);
                showMessage('スプレッドシートへの書き込みに失敗しました: ' + (error.result?.error?.message || error.message), 'error');
            }
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: ''
            });
            gisInited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                tryAutoSignIn();
            }
        }
        
        function addVideoPath() {
            if (!state.formData.videoPaths) {
                state.formData.videoPaths = [];
            }
            
            if (state.formData.videoPaths.length < 3) {
                state.formData.videoPaths.push({
                    name: `動画 ${state.formData.videoPaths.length + 1}`,
                    path: '',
                    uploadDate: new Date().toISOString()
                });
                render();
            } else {
                showMessage('動画パスは最大3つまで追加できます', 'error');
            }
        }

        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                accessToken = gapi.client.getToken().access_token;
                state.isSignedIn = true;
                localStorage.setItem('google_access_token', JSON.stringify(gapi.client.getToken()));
                
                // ユーザー情報を取得
                await getUserInfo();
                
                await loadFromDrive();
                render();
            };
        
            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        async function tryAutoSignIn() {
            const savedToken = localStorage.getItem('google_access_token');
            if (savedToken) {
                try {
                    const token = JSON.parse(savedToken);
                    gapi.client.setToken(token);
                    accessToken = token.access_token;
                    await gapi.client.drive.files.list({
                        pageSize: 1,
                        supportsAllDrives: true
                    });
                    state.isSignedIn = true;
                    
                    // ユーザー情報を取得
                    await getUserInfo();
                    
                    await loadFromDrive();
                    render();
                } catch (error) {
                    console.log('Saved token expired');
                    localStorage.removeItem('google_access_token');
                    render();
                }
            } else {
                render();
            }
        }

        async function getUserInfo() {
            try {
                const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                    headers: {
                        'Authorization': 'Bearer ' + accessToken
                    }
                });
                const userInfo = await response.json();
                state.userName = userInfo.name || userInfo.email;
            } catch (error) {
                console.error('ユーザー情報取得エラー:', error);
                state.userName = null;
            }
        }

        function handleSignOut() {
            gapi.client.setToken(null);
            localStorage.removeItem('google_access_token');
            accessToken = null;
            state.isSignedIn = false;
            state.userName = null;
            state.posts = {};
            state.folderId = null;
            fileId = null;
            render();
            showMessage('ログアウトしました', 'success');
        }

        async function refreshTokenIfNeeded() {
            if (!state.isSignedIn) return;
            
            try {
                // トークンの有効性をテスト
                await gapi.client.drive.files.list({
                    pageSize: 1,
                    supportsAllDrives: true
                });
            } catch (error) {
                console.log('Token expired, refreshing...');
                
                // トークンが期限切れの場合、再認証を試みる
                tokenClient.callback = async (resp) => {
                    if (resp.error !== undefined) {
                        console.error('Token refresh failed:', resp);
                        showMessage('認証が切れました。再ログインしてください。', 'error');
                        handleSignOut();
                        return;
                    }
                    accessToken = gapi.client.getToken().access_token;
                    state.isSignedIn = true;
                    localStorage.setItem('google_access_token', JSON.stringify(gapi.client.getToken()));
                    await getUserInfo();
                    showMessage('認証を更新しました', 'success');
                    render();
                };
                
                // プロンプトなしで再認証を試みる
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        async function loadFromDrive() {
            try {
                let folderId = null;
                console.log('🔍 指定フォルダ内を検索開始...');
                
                const folderResponse = await gapi.client.drive.files.list({
                    q: `name='${FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false and '${TARGET_FOLDER_ID}' in parents`,
                    fields: 'files(id, name)',
                    spaces: 'drive',
                    supportsAllDrives: true,
                    includeItemsFromAllDrives: true,
                    corpora: 'drive',
                    driveId: SHARED_DRIVE_ID
                });
        
                if (folderResponse.result.files && folderResponse.result.files.length > 0) {
                    folderId = folderResponse.result.files[0].id;
                    console.log('✅ 指定フォルダ内でフォルダ発見');
                    showMessage('指定フォルダ内のフォルダに接続しました', 'success');
                } else {
                    console.log('❌ フォルダが見つかりません');
                    showMessage('「SNS投稿管理」フォルダが見つかりません。管理者に連絡してください。', 'error');
                    state.isSignedIn = false;
                    handleSignOut();
                    return;
                }
        
                state.folderId = folderId;
                state.currentYear = state.currentDate.getFullYear(); // この行を追加
                
                // 現在表示中の年のデータを読み込む
                await loadYearData();
                
                // Twitter APIトークンを読み込む
                // await loadTwitterTokens();
                
                console.log('✅ セットアップ完了');
            } catch (error) {
                console.error('❌ 共有ドライブ読み込みエラー:', error);
                showMessage('エラー: ' + (error.result?.error?.message || error.message), 'error');
            }
        }
        
        async function loadYearData() {
            if (!state.folderId) return;
            
            const currentYear = state.currentDate.getFullYear();
            const fileName = `sns_calendar_data_${currentYear}.json`;
            
            try {
                const response = await gapi.client.drive.files.list({
                    q: `name='${fileName}' and '${state.folderId}' in parents and trashed=false`,
                    fields: 'files(id, name, modifiedTime)',
                    spaces: 'drive',
                    supportsAllDrives: true,
                    includeItemsFromAllDrives: true
                });
        
                const files = response.result.files;
                if (files && files.length > 0) {
                    fileId = files[0].id;
                    const serverModifiedTime = files[0].modifiedTime; // Driveのタイムスタンプを保存
                    
                    const fileContent = await gapi.client.drive.files.get({
                        fileId: fileId,
                        alt: 'media',
                        supportsAllDrives: true
                    });
        
                    if (fileContent.body) {
                        const data = JSON.parse(fileContent.body);
                        state.posts = data.posts || {};
                        state.lastUpdated = serverModifiedTime; // modifiedTimeを使用
                        console.log(`✅ ${currentYear}年のデータ読み込み成功`);
                        showMessage(`${currentYear}年のデータを読み込みました`, 'success');
                    }
                } else {
                    // JSONファイルが見つからない場合は空のデータで開始
                    console.log(`📝 ${currentYear}年のJSONファイルが見つかりません。`);
                    state.posts = {};
                    state.lastUpdated = null;
                    fileId = null;
                    showMessage(`${currentYear}年の新規データを作成します`, 'success');
                }
            } catch (error) {
                console.error('年データ読み込みエラー:', error);
                state.posts = {};
                state.lastUpdated = null;
                fileId = null;
            }
        }

        async function checkForUpdates() {
            // トークンの有効性をチェック
            await refreshTokenIfNeeded();
            
            try {
                const currentYear = state.currentDate.getFullYear();
                const fileName = `sns_calendar_data_${currentYear}.json`;
                
                const response = await gapi.client.drive.files.list({
                    q: `name='${fileName}' and '${state.folderId}' in parents and trashed=false`,
                    fields: 'files(id, modifiedTime)',
                    spaces: 'drive',
                    supportsAllDrives: true,
                    includeItemsFromAllDrives: true
                });
        
                if (response.result.files && response.result.files.length > 0) {
                    const serverModifiedTime = new Date(response.result.files[0].modifiedTime);
                    const localModifiedTime = state.lastUpdated ? new Date(state.lastUpdated) : new Date(0);
                    
                    // 1秒以上の差がある場合のみ競合とみなす（自分の保存との誤判定を防ぐ）
                    if (serverModifiedTime.getTime() - localModifiedTime.getTime() > 1000) {
                        if (confirm('他のユーザーがデータを更新しました。最新データを読み込みますか？\n\n※編集中の場合、編集内容は保持されます。')) {
                            const currentFormData = state.selectedDate ? {...state.formData} : null;
                            const currentEditingPostId = state.editingPostId;
                            const currentViewMode = state.viewMode;
                            const currentSelectedDate = state.selectedDate;
                            
                            await loadYearData();
                            
                            // 編集中だった場合、フォームデータを復元
                            if (currentSelectedDate) {
                                state.selectedDate = currentSelectedDate;
                                state.editingPostId = currentEditingPostId;
                                state.viewMode = currentViewMode;
                                if (currentFormData) {
                                    state.formData = currentFormData;
                                }
                            }
                            
                            render();
                            showMessage('最新データを読み込みました', 'success');
                        }
                    }
                }
            } catch (error) {
                console.error('更新チェックエラー:', error);
            }
        }
        
        async function saveToDrive() {
            if (!state.isSignedIn || !state.folderId || state.isSaving) return;
            
            // トークンの有効性をチェック
            await refreshTokenIfNeeded();
            
            state.isSaving = true;
            render();
        
            try {
                // 保存前に競合チェック
                if (fileId) {
                    const checkResponse = await gapi.client.drive.files.get({
                        fileId: fileId,
                        fields: 'modifiedTime',
                        supportsAllDrives: true
                    });
                    
                    const serverModifiedTime = new Date(checkResponse.result.modifiedTime);
                    const localModifiedTime = state.lastUpdated ? new Date(state.lastUpdated) : new Date(0);
                    
                    // 1秒以上の差がある場合のみ競合とみなす（自分の保存との誤判定を防ぐ）
                    if (serverModifiedTime.getTime() - localModifiedTime.getTime() > 1000) {
                        // 編集中の内容を保持
                        const currentFormData = {...state.formData};
                        const currentEditingPostId = state.editingPostId;
                        const currentViewMode = state.viewMode;
                        const currentSelectedDate = state.selectedDate;
                        
                        // 最新データを自動で読み込む
                        await loadYearData();
                        
                        // 画面を復元
                        state.selectedDate = currentSelectedDate;
                        state.editingPostId = currentEditingPostId;
                        state.viewMode = currentViewMode;
                        state.formData = currentFormData;
                        
                        showMessage('最新データを読み込みました。保存を続行します...', 'success');
                        
                        // 読み込んだ最新データに対して保存を実行（再帰的に実行）
                        state.isSaving = false;
                        await saveToDrive();
                        return;
                    }
                }
        
                const currentYear = state.currentDate.getFullYear();
                const fileName = `sns_calendar_data_${currentYear}.json`;
                
                const now = new Date().toISOString();
                const content = JSON.stringify({
                    posts: state.posts,
                    lastUpdated: now
                });
        
                const file = new Blob([content], { type: 'application/json' });
                const metadata = fileId ? {
                    name: fileName,
                    mimeType: 'application/json'
                } : {
                    name: fileName,
                    mimeType: 'application/json',
                    parents: [state.folderId]
                };
        
                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', file);
        
                const url = fileId
                    ? `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart&supportsAllDrives=true`
                    : `https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&supportsAllDrives=true`;
        
                const response = await fetch(url, {
                    method: fileId ? 'PATCH' : 'POST',
                    headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),
                    body: form
                });
        
                if (!response.ok) {
                    throw new Error(`保存に失敗: ${response.status}`);
                }
        
                const result = await response.json();
                if (!fileId) {
                    fileId = result.id;
                }
        
                // 保存後にDriveのmodifiedTimeを再取得して同期
                const updatedFile = await gapi.client.drive.files.get({
                    fileId: fileId,
                    fields: 'modifiedTime',
                    supportsAllDrives: true
                });
                state.lastUpdated = updatedFile.result.modifiedTime;
                
                showMessage('共有ドライブに保存しました！', 'success');
        
            } catch (error) {
                console.error('保存エラー:', error);
                showMessage('保存に失敗: ' + error.message, 'error');
            } finally {
                state.isSaving = false;
                render();
            }
        }

        async function updateSpreadsheetInBackground() {
            try {
                if (Object.keys(state.posts).length === 0) return;
        
                const headers = [['投稿日', 'タイトル', '投稿先', '投稿テキスト', 'チェック完了者', '動画パス', '最終更新日時']];
                const rows = [];
                
                Object.keys(state.posts).sort().forEach(date => {
                    state.posts[date].forEach(post => {
                        const platforms = (post.platforms || [post.platform]).map(p => {
                            const badges = { x: '𝕏', instagram: 'Instagram', line: 'LINE', stumaga: 'スタマガ' };
                            return badges[p] || p;
                        }).join(', ');
                        
                        const checks = (post.checks || []).join(', ');
                        const videoPaths = (post.videoPaths || []).map(v => v.path).filter(p => p).join(', ');
                        
                        rows.push([
                            date,
                            post.title || '無題',
                            platforms,
                            post.text || '',
                            checks,
                            videoPaths,
                            new Date().toLocaleString('ja-JP')
                        ]);
                    });
                });
        
                await gapi.client.sheets.spreadsheets.values.clear({
                    spreadsheetId: SPREADSHEET_ID,
                    range: 'シート1!A1:Z'
                });
        
                await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId: SPREADSHEET_ID,
                    range: 'シート1!A1',
                    valueInputOption: 'RAW',
                    resource: { values: [...headers, ...rows] }
                });
        
                console.log('✅ スプレッドシート自動更新完了');
        
            } catch (error) {
                console.error('スプレッドシート自動更新エラー:', error);
                // エラーが出てもユーザーには通知しない（バックグラウンド処理のため）
            }
        }

        function showMessage(message, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg text-white z-50 ${type === 'success' ? 'bg-green-500' : 'bg-red-500'}`;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            setTimeout(() => messageDiv.remove(), 3000);
        }

        function formatDateTime(isoString) {
            if (!isoString) return '';
            const date = new Date(isoString);
            return `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        }

        function formatDate(date) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }

        function getDaysInMonth(date) {
            const year = date.getFullYear();
            const month = date.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            return {
                daysInMonth: lastDay.getDate(),
                startingDayOfWeek: firstDay.getDay()
            };
        }

        async function savePost() {
            if (!state.formData.title && !state.formData.text) return;
         
            // 画像と動画を分離
            const imageFiles = state.formData.images.filter(file => file.type === 'image');
            const videoFiles = state.formData.images.filter(file => file.type === 'video');
         
            const newPost = {
                ...state.formData,
                id: state.editingPostId || Date.now(),
                images: imageFiles.map(file => ({
                    type: file.type,
                    name: file.name,
                    size: file.data ? file.data.length : 0,
                    data: file.data,
                    uploadDate: new Date().toISOString()
                })),
                checks: state.formData.checks || [],
                completedChecks: state.formData.completedChecks || [],
                productNumber: state.formData.productNumber || '',
                embedProduct: state.formData.embedProduct || false,
                remarks: state.formData.remarks || '',
                links: state.formData.links || [],
            };
         
            const datePosts = state.posts[state.selectedDate] || [];
            if (state.editingPostId) {
                // 全ての日付から該当する投稿を検索
                let oldDateStr = null;
                for (const dateStr in state.posts) {
                    const foundPost = state.posts[dateStr].find(p => p.id === state.editingPostId);
                    if (foundPost) {
                        oldDateStr = dateStr;
                        break;
                    }
                }
                
                // 元の日付と異なる場合は移動
                if (oldDateStr && oldDateStr !== state.selectedDate) {
                    // 元の日付から削除
                    const oldDatePosts = state.posts[oldDateStr].filter(p => p.id !== state.editingPostId);
                    if (oldDatePosts.length === 0) {
                        delete state.posts[oldDateStr];
                    } else {
                        state.posts[oldDateStr] = oldDatePosts;
                    }
                    
                    // 新しい日付に追加
                    state.posts[state.selectedDate] = [...datePosts, newPost];
                    showMessage('投稿日を変更して保存しました', 'success');
                } else {
                    // 同じ日付内で更新
                    const existingPostIndex = datePosts.findIndex(p => p.id === state.editingPostId);
                    
                    if (existingPostIndex !== -1) {
                        state.posts[state.selectedDate] = datePosts.map(p => p.id === state.editingPostId ? newPost : p);
                    } else {
                        state.posts[state.selectedDate] = [...datePosts, newPost];
                        showMessage('投稿が削除されていたため、新規投稿として保存しました', 'success');
                    }
                }
            } else {
                state.posts[state.selectedDate] = [...datePosts, newPost];
                // 新規投稿の場合、作成した投稿のIDを設定
                state.editingPostId = newPost.id;
            }
         
            await saveToDrive();
            
            // 閲覧モードに切り替え
            state.viewMode = 'view';
            render();
        }
        
        function cancelEdit() {
            state.selectedDate = null;
            state.editingPostId = null;
            state.viewMode = 'edit';
            state.formData = {title: '', platforms: [], text: '', images: [], checks: [], completedChecks: []};
        }

        function confirmDelete(dateStr, postId) {
            if (confirm('本当にこの投稿を削除しますか？\nこの操作は取り消せません。')) {
                deletePost(dateStr, postId);
            }
        }

        async function deletePost(dateStr, postId) {
            const datePosts = state.posts[dateStr].filter(p => p.id !== postId);
            if (datePosts.length === 0) {
                delete state.posts[dateStr];
            } else {
                state.posts[dateStr] = datePosts;
            }
            await saveToDrive();
            cancelEdit();
            render();
        }

        function addLink() {
            if (!state.formData.links) {
                state.formData.links = [];
            }
            
            if (state.formData.links.length < 5) {
                state.formData.links.push('');
                render();
            } else {
                showMessage('リンク先は最大5つまで追加できます', 'error');
            }
        }
        
        function removeLink(index) {
            state.formData.links = state.formData.links.filter((_, i) => i !== index);
            render();
        }

        function openEditForm(day, postId = null) {
            const dateStr = formatDate(new Date(state.currentDate.getFullYear(), state.currentDate.getMonth(), day));
            state.selectedDate = dateStr;
        
            if (postId && state.posts[dateStr]) {
                const post = state.posts[dateStr].find(p => p.id === postId);
                if (post) {
                    state.formData = { ...post };
                    if (!state.formData.platforms && state.formData.platform) {
                        state.formData.platforms = [state.formData.platform];
                    }
                    if (!state.formData.checks) {
                        state.formData.checks = [];
                    }
                    if (!state.formData.completedChecks) {
                        state.formData.completedChecks = [];
                    }
                    if (!state.formData.productNumber) {
                        state.formData.productNumber = '';
                    }
                    if (!state.formData.embedProduct) {
                        state.formData.embedProduct = false;
                    }
                    if (!state.formData.remarks) {
                        state.formData.remarks = '';
                    }
                    if (!state.formData.links) {
                        state.formData.links = [];
                    }
                    
                    state.editingPostId = postId;
                    state.viewMode = 'view';
                }
            } else {
                state.formData = {
                    title: '', 
                    platforms: [], 
                    text: '', 
                    images: [], 
                    checks: [],
                    productNumber: '',
                    embedProduct: false,
                    remarks: '',
                    links: [''],
                };
                state.editingPostId = null;
                state.viewMode = 'edit';
            }
            render();
        }

        function switchToEditMode() {
            state.viewMode = 'edit';
            render();
        }

        function changeSelectedDate(newDate) {
            if (!newDate || newDate === state.selectedDate) return;
            
            // 新しい日付を設定
            const oldDate = state.selectedDate;
            state.selectedDate = newDate;
            
            // カレンダー表示も新しい日付の月に移動
            const newDateObj = new Date(newDate);
            state.currentDate = new Date(newDateObj.getFullYear(), newDateObj.getMonth(), 1);
            
            render();
        }

        function togglePlatform(platform) {
            if (state.formData.platforms.includes(platform)) {
                state.formData.platforms = state.formData.platforms.filter(p => p !== platform);
            } else {
                state.formData.platforms.push(platform);
            }
            render();
        }

        function handleImageSelect(e) {
            const files = Array.from(e.target.files);
            console.log('選択されたファイルの数:', files.length);
            
            if (files.length === 0) return;
        
            const remainingSlots = 20 - state.formData.images.length; // 5から20に変更
            const filesToProcess = files.slice(0, remainingSlots);
            let processed = 0;
            const newFiles = [];
        
            filesToProcess.forEach(file => {
                console.log('処理するファイル:', file.name, 'タイプ:', file.type, 'サイズ:', file.size);
        
                // 100MBのファイルサイズ制限を追加
                if (file.size > 100 * 1024 * 1024) {
                    showMessage(`ファイルサイズが大きすぎます: ${file.name} (100MB以下にしてください)`, 'error');
                    return;
                }
        
                const reader = new FileReader();
                reader.onload = (event) => {
                    console.log('ファイル読み込み完了:', file.name);
                    console.log('データ長:', event.target.result ? event.target.result.length : 'データなし');
                    
                    newFiles.push({
                        type: file.type.startsWith('image/') ? 'image' : 'video',
                        data: event.target.result,
                        name: file.name,
                        originalFile: file
                    });
                    processed++;
                    if (processed === filesToProcess.length) {
                        state.formData.images = [...state.formData.images, ...newFiles];
                        console.log('追加後の画像数:', state.formData.images.length);
                        render();
                    }
                };
                reader.readAsDataURL(file);
            });
        }
        
        // removeImage関数を修正
        function removeImage(index) {
            state.formData.images = state.formData.images.filter((_, i) => i !== index);
            render();
        }
        
        // downloadImage関数を修正し、動画もダウンロード可能に
        function downloadImage(fileData, title, index) {
            if (!fileData || !fileData.data) {
                console.error('ダウンロードするファイルデータがありません', fileData);
                return;
            }
            const link = document.createElement('a');
            link.href = fileData.data;
            link.download = `${title || 'media'}_${index + 1}${getFileExtension(fileData)}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function getFileExtension(file) {
            if (file.type === 'image') {
                const match = file.data.match(/^data:image\/([a-zA-Z0-9]+);/);
                return match ? `.${match[1]}` : '.png';
            }
            if (file.type === 'video') {
                const match = file.data.match(/^data:video\/([a-zA-Z0-9]+);/);
                return match ? `.${match[1]}` : '.mp4';
            }
            return '';
        }

        function goToToday() {
            state.currentDate = new Date();
            render();
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showMessage('コピーしました！', 'success');
            });
        }

        function toggleCheckCompletion(checkText) {
            if (!state.formData.completedChecks) {
                state.formData.completedChecks = [];
            }
            
            if (state.formData.completedChecks.includes(checkText)) {
                state.formData.completedChecks = state.formData.completedChecks.filter(c => c !== checkText);
            } else {
                state.formData.completedChecks.push(checkText);
            }
            
            // 自動保存
            saveToDrive();
            render();
        }

        function addViewCheck(inputId) {
            const input = document.getElementById(inputId);
            const value = input.value.trim();
            
            if (!state.formData.checks) {
                state.formData.checks = [];
            }
            
            if (value && !state.formData.checks.includes(value)) {
                state.formData.checks.push(value);
                input.value = '';
                saveToDrive(); // 自動保存
                render();
            }
        }
        
        function removeViewCheck(index) {
            state.formData.checks = state.formData.checks.filter((_, i) => i !== index);
            saveToDrive(); // 自動保存
            render();
        }

        function addCheckPerson() {
            const input = document.getElementById('checkPersonInput');
            const value = input.value.trim();
            
            if (!state.formData.checks) {
                state.formData.checks = [];
            }
            
            if (value && !state.formData.checks.includes(value)) {
                state.formData.checks.push(value);
                input.value = '';
                saveToDrive(); // 自動保存
                render();
            }
        }
        
        function removeCheckPerson(index) {
            state.formData.checks = state.formData.checks.filter((_, i) => i !== index);
            saveToDrive(); // 自動保存
            render();
        }

        async function postToX() {
            // チェック完了者がいるか確認
            if (!state.formData.checks || state.formData.checks.length === 0) {
                showMessage('❌ 投稿前にチェックを完了してください', 'error');
                return;
            }
            
            // 投稿内容を準備
            const postText = state.formData.text || '';
            
            // テキストまたはメディアが必要
            if (!postText && !state.formData.embedProduct && (!state.formData.images || state.formData.images.length === 0)) {
                showMessage('❌ 投稿テキストまたはメディアを入力してください', 'error');
                return;
            }
            const links = (state.formData.links || []).filter(l => l.trim());
            let fullText = postText;
            
            // リンクを改行して追加
            if (links.length > 0) {
                fullText += '\n\n' + links.join('\n');
            }
            
            // 280文字制限チェック
            if (fullText.length > 280) {
                showMessage(`❌ テキストが長すぎます（${fullText.length}/280文字）`, 'error');
                return;
            }
            
            // 動画埋め込みの場合、DriveのファイルIDを取得
            let videoFileId = null;
            if (state.formData.embedProduct && state.formData.productNumber) {
                try {
                    const response = await gapi.client.drive.files.list({
                        q: `name='${state.formData.productNumber}.mp4' and '${VIDEO_FOLDER_ID}' in parents and trashed=false`,
                        fields: 'files(id, name)',
                        spaces: 'drive',
                        supportsAllDrives: true,
                        includeItemsFromAllDrives: true
                    });
                    
                    if (response.result.files && response.result.files.length > 0) {
                        videoFileId = response.result.files[0].id;
                        console.log('✅ 動画ファイルID取得:', videoFileId);
                    } else {
                        showMessage(`❌ 動画ファイル「${state.formData.productNumber}.mp4」が見つかりませんでした`, 'error');
                        return;
                    }
                } catch (error) {
                    console.error('動画ファイルID取得エラー:', error);
                    showMessage('❌ 動画ファイルの取得に失敗しました', 'error');
                    return;
                }
            }
            
            // 手動アップロードした画像のファイルIDを準備
            const imageFileIds = [];
            if (state.formData.images && state.formData.images.length > 0) {
                showMessage('⏳ 画像をGoogle Driveにアップロード中...', 'success');
                
                for (const image of state.formData.images) {
                    try {
                        // Base64からBlobに変換
                        const response = await fetch(image.data);
                        const blob = await response.blob();
                        
                        // Google Driveにアップロード
                        const metadata = {
                            name: `temp_${Date.now()}_${image.name}`,
                            parents: [VIDEO_FOLDER_ID]
                        };
                        
                        const form = new FormData();
                        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                        form.append('file', blob);
                        
                        const uploadResponse = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&supportsAllDrives=true', {
                            method: 'POST',
                            headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),
                            body: form
                        });
                        
                        if (uploadResponse.ok) {
                            const result = await uploadResponse.json();
                            imageFileIds.push(result.id);
                            console.log('✅ 画像アップロード成功:', result.id);
                        }
                    } catch (error) {
                        console.error('画像アップロードエラー:', error);
                        showMessage('❌ 画像のアップロードに失敗しました', 'error');
                        return;
                    }
                }
            }
            
            // 確認ダイアログ
            const previewText = fullText.length > 100 ? fullText.substring(0, 100) + '...' : fullText;
            let mediaText = '';
            if (videoFileId) mediaText += '\n🎬 動画: 1個';
            if (imageFileIds.length > 0) mediaText += `\n📷 画像: ${imageFileIds.length}個`;
            
            if (!confirm(`以下の内容でXに投稿します。よろしいですか？\n\n${previewText}${mediaText}`)) {
                return;
            }
            
            try {
                showMessage('⏳ Xに投稿中...', 'success');
                
                // Google Apps ScriptのWeb APIを呼び出す
                const GAS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbydrnEuxFI4a8yaTcsFOPQTnXJA1Z2tEX_wZU6bU5gjS80k-r-YLoX_Fe8qgxy4UrsNgw/exec'; // ← 後で設定
                
                const requestData = {
                    text: fullText,
                    videoFileId: videoFileId,
                    imageFileIds: imageFileIds
                };
                
                const response = await fetch(GAS_WEB_APP_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain'
                    },
                    body: JSON.stringify(requestData)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('✅ Xに投稿しました！', 'success');
                } else {
                    showMessage(`❌ X投稿に失敗: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('X投稿エラー:', error);
                showMessage(`❌ X投稿に失敗しました: ${error.message}`, 'error');
            }
        }

async function postToInstagram() {
            // チェック完了者がいるか確認
            if (!state.formData.checks || state.formData.checks.length === 0) {
                showMessage('❌ 投稿前にチェックを完了してください', 'error');
                return;
            }
            
            // 画像が必須（Instagramはテキストのみ投稿不可）
            if (!state.formData.images || state.formData.images.length === 0) {
                showMessage('❌ Instagramには画像が必須です', 'error');
                return;
            }
            
            // 投稿内容を準備
            const caption = state.formData.text || '';
            
            // リンクを追加
            const links = (state.formData.links || []).filter(l => l.trim());
            let fullCaption = caption;
            if (links.length > 0) {
                fullCaption += '\n\n' + links.join('\n');
            }
            
            // 2200文字制限チェック
            if (fullCaption.length > 2200) {
                showMessage(`❌ キャプションが長すぎます（${fullCaption.length}/2200文字）`, 'error');
                return;
            }
            
            // 確認ダイアログ
            const previewText = fullCaption.length > 100 ? fullCaption.substring(0, 100) + '...' : fullCaption;
            const mediaText = `\n📷 画像: ${state.formData.images.length}個`;
            
            if (!confirm(`以下の内容でInstagramに投稿します。よろしいですか？\n\n${previewText}${mediaText}`)) {
                return;
            }
            
            try {
                showMessage('⏳ Instagramに投稿中...', 'success');
                
                // 画像を1枚ずつCloudinaryにアップロード
                const imageUrls = [];
                const CLOUDINARY_CLOUD_NAME = 'duusvznln';
                const CLOUDINARY_UPLOAD_PRESET = 'instagram_upload';
                
                for (let i = 0; i < state.formData.images.length; i++) {
                    const image = state.formData.images[i];
                    
                    // Cloudinaryにアップロード
                    const cloudinaryFormData = new FormData();
                    cloudinaryFormData.append('file', image.data);
                    cloudinaryFormData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
                    
                    const cloudinaryResponse = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`, {
                        method: 'POST',
                        body: cloudinaryFormData
                    });
                    
                    if (!cloudinaryResponse.ok) {
                        const errorData = await cloudinaryResponse.json();
                        throw new Error(`画像のアップロードに失敗: ${errorData.error?.message || 'Unknown error'}`);
                    }
                    
                    const cloudinaryResult = await cloudinaryResponse.json();
                    const imageUrl = cloudinaryResult.secure_url;
                    imageUrls.push(imageUrl);
                    
                    console.log(`✅ 画像 ${i + 1} アップロード成功:`, imageUrl);
                    showMessage(`⏳ 画像 ${i + 1}/${state.formData.images.length} をアップロード中...`, 'success');
                }
                
                console.log('✅ 全画像アップロード完了。Instagram APIへ送信開始...');
                console.log('📝 画像URLs:', imageUrls);
                
                // Instagram Graph APIでメディアコンテナを作成
                const mediaIds = [];
                
                for (let i = 0; i < imageUrls.length; i++) {
                    const imageUrl = imageUrls[i];
                    
                    const containerUrl = state.formData.images.length === 1
                        ? `https://graph.facebook.com/v18.0/${INSTAGRAM_ACCOUNT_ID}/media?image_url=${encodeURIComponent(imageUrl)}&caption=${encodeURIComponent(fullCaption)}&access_token=${INSTAGRAM_ACCESS_TOKEN}`
                        : `https://graph.facebook.com/v18.0/${INSTAGRAM_ACCOUNT_ID}/media?image_url=${encodeURIComponent(imageUrl)}&is_carousel_item=true&access_token=${INSTAGRAM_ACCESS_TOKEN}`;
                    
                    console.log('📝 リクエストURL:', containerUrl);
                    console.log('📝 アカウントID:', INSTAGRAM_ACCOUNT_ID);
                    console.log('📝 トークン（最初の20文字）:', INSTAGRAM_ACCESS_TOKEN.substring(0, 20));
                    
                    const containerResponse = await fetch(containerUrl, { method: 'POST' });
                    
                    console.log('📝 レスポンスステータス:', containerResponse.status);
                    
                    if (!containerResponse.ok) {
                        const errorData = await containerResponse.json();
                        console.error('📝 エラーレスポンス:', errorData);
                        throw new Error(`メディアコンテナの作成に失敗: ${JSON.stringify(errorData.error || errorData)}`);
                    }
                    
                    const containerResult = await containerResponse.json();
                    mediaIds.push(containerResult.id);
                }
                
                showMessage('⏳ 投稿を公開中...', 'success');
                
                // 投稿を公開
                let publishUrl;
                if (state.formData.images.length === 1) {
                    // 単一画像投稿
                    publishUrl = `https://graph.facebook.com/v18.0/${INSTAGRAM_ACCOUNT_ID}/media_publish?creation_id=${mediaIds[0]}&access_token=${INSTAGRAM_ACCESS_TOKEN}`;
                } else {
                    // カルーセル投稿
                    const carouselUrl = `https://graph.facebook.com/v18.0/${INSTAGRAM_ACCOUNT_ID}/media?media_type=CAROUSEL&children=${mediaIds.join(',')}&caption=${encodeURIComponent(fullCaption)}&access_token=${INSTAGRAM_ACCESS_TOKEN}`;
                    const carouselResponse = await fetch(carouselUrl, { method: 'POST' });
                    
                    if (!carouselResponse.ok) {
                        const errorData = await carouselResponse.json();
                        throw new Error(`カルーセルの作成に失敗: ${errorData.error?.message || 'Unknown error'}`);
                    }
                    
                    const carouselResult = await carouselResponse.json();
                    publishUrl = `https://graph.facebook.com/v18.0/${INSTAGRAM_ACCOUNT_ID}/media_publish?creation_id=${carouselResult.id}&access_token=${INSTAGRAM_ACCESS_TOKEN}`;
                }
                
                const publishResponse = await fetch(publishUrl, { method: 'POST' });
                
                if (!publishResponse.ok) {
                    const errorData = await publishResponse.json();
                    throw new Error(`投稿の公開に失敗: ${errorData.error?.message || 'Unknown error'}`);
                }
                
                const publishResult = await publishResponse.json();
                
                showMessage('✅ Instagramに投稿しました！', 'success');
                
            } catch (error) {
                console.error('Instagram投稿エラー:', error);
                console.error('エラー詳細:', JSON.stringify(error, null, 2));
                if (error.result) {
                    console.error('API レスポンス:', error.result);
                }
                showMessage(`❌ Instagram投稿に失敗しました: ${error.message || error.toString() || 'Unknown error'}`, 'error');
            }
        }
    
      function render() {
            const { daysInMonth, startingDayOfWeek } = getDaysInMonth(state.currentDate);
            const monthName = state.currentDate.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long' });
            const today = new Date();
            const isCurrentMonth = state.currentDate.getMonth() === today.getMonth() && state.currentDate.getFullYear() === today.getFullYear();

            const platformBadges = {
                x: { label: '𝕏', color: 'bg-black' },
                instagram: { label: 'IG', color: 'bg-gradient-to-r from-purple-500 to-pink-500' },
                line: { label: 'L', color: 'bg-green-500' },
                stumaga: { label: 'M', color: 'bg-orange-500' },
                youtube: { label: 'YT', color: 'bg-red-600' }
            };

            let calendarHTML = '';
            const weekDays = ['日', '月', '火', '水', '木', '金', '土'];
            weekDays.forEach((day, index) => {
                const dayColor = index === 0 ? 'text-red-600' : (index === 6 ? 'text-blue-600' : 'text-gray-600');
                calendarHTML += `<div class="text-center font-bold ${dayColor} py-2">${day}</div>`;
            });
            
            for (let i = 0; i < startingDayOfWeek; i++) {
                calendarHTML += '<div class="p-2"></div>';
            }
            
            for (let day = 1; day <= daysInMonth; day++) {
                const dateStr = formatDate(new Date(state.currentDate.getFullYear(), state.currentDate.getMonth(), day));
                const dayPosts = state.posts[dateStr] || [];
                const isToday = isCurrentMonth && day === today.getDate();
                
                // 曜日を計算（0=日曜, 6=土曜）
                const currentDayOfWeek = new Date(state.currentDate.getFullYear(), state.currentDate.getMonth(), day).getDay();
                const dayColor = currentDayOfWeek === 0 ? 'text-red-600' : (currentDayOfWeek === 6 ? 'text-blue-600' : 'text-gray-700');
                const todayBorder = isToday ? 'border-blue-400 bg-blue-50' : 'border-gray-200';
            
                const disabledClass = state.isSignedIn ? '' : 'opacity-50 cursor-not-allowed';
                const hoverClass = state.isSignedIn ? 'hover:border-blue-200' : '';
                
                calendarHTML += `
                    <div class="p-2 min-h-24 border rounded-lg transition-all bg-white ${todayBorder} ${hoverClass} ${disabledClass}">
                        <div class="font-semibold mb-2 ${dayColor}">${day}${isToday ? '<span class="ml-1 text-xs">●</span>' : ''}</div>
                        <div class="space-y-1">
                            ${dayPosts.map(post => {
                                const platforms = post.platforms || [post.platform];
                                const clickHandler = state.isSignedIn ? `onclick="openEditForm(${day}, ${post.id})"` : `onclick="showMessage('先にGoogle Driveに接続してください', 'error')"`;
                                const postHoverClass = state.isSignedIn ? 'hover:border-blue-400 cursor-pointer hover:shadow-sm' : 'cursor-not-allowed';
                                return `<div ${clickHandler} class="text-xs bg-white p-2 rounded border border-gray-200 ${postHoverClass} transition-all">
                                    <div class="flex items-center gap-1 flex-wrap">
                                        ${platforms.map(p => {
                                            const badge = platformBadges[p];
                                            return `<span class="${badge.color} text-white px-1 py-0.5 rounded text-[9px]">${badge.label}</span>`;
                                        }).join('')}
                                        <span class="font-semibold text-gray-700 truncate text-[11px]">${post.title || '無題'}</span>
                                    </div>
                                </div>`;
                            }).join('')}
                            <button ${state.isSignedIn ? `onclick="openEditForm(${day})"` : `onclick="showMessage('先にGoogle Driveに接続してください', 'error')"`} class="w-full text-[11px] ${state.isSignedIn ? 'text-gray-400 hover:text-gray-600 hover:bg-gray-50 cursor-pointer' : 'text-gray-300 cursor-not-allowed'} py-1 flex items-center justify-center gap-1 rounded transition-colors">
                                <span>+</span> 追加
                            </button>
                        </div>
                    </div>
                `;
            }

            let editFormHTML = '';
            if (state.selectedDate) {
                const platformButtons = [
                    {value: 'x', label: '𝕏', color: 'bg-black'},
                    {value: 'instagram', label: 'Instagram', color: 'bg-gradient-to-r from-purple-500 to-pink-500'},
                    {value: 'line', label: 'LINE', color: 'bg-green-500'},
                    {value: 'stumaga', label: 'スタマガ', color: 'bg-orange-500'}
                ];

                if (state.viewMode === 'view') {
                    const platforms = state.formData.platforms || [state.formData.platform];
                    editFormHTML = `<div class="bg-white rounded-2xl shadow-xl p-4">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center gap-3">
                                <div class="text-2xl font-bold text-gray-800">${state.selectedDate}</div>
                                <div class="flex gap-1 flex-wrap">
                                    ${platforms.map(p => {
                                        const badge = platformBadges[p];
                                        return `<span class="${badge.color} text-white px-2 py-1 rounded text-sm">${badge.label}</span>`;
                                    }).join('')}
                                </div>
                            </div>
                            <button onclick="cancelEdit(); render();" class="p-1 hover:bg-gray-100 rounded-lg transition-colors">
                                <span class="text-xl">×</span>
                            </button>
                        </div>
                        <div class="space-y-3">
                            <div>
                                <div class="font-semibold text-gray-800 text-lg">${state.formData.title || '無題'}</div>
                            </div>
                            ${state.formData.productNumber ? `
                                <div>
                                    <div class="flex items-center gap-2">
                                        <div class="text-sm flex-1">
                                            <span class="font-semibold">商品番号:</span> 
                                            <a href="https://winds-score.com/products/${state.formData.productNumber}" target="_blank" class="text-blue-600 hover:text-blue-800 underline">${state.formData.productNumber}</a>
                                            ${state.formData.embedProduct ? '<span class="ml-2 bg-blue-100 text-blue-700 px-2 py-0.5 rounded text-xs">動画埋込</span>' : ''}
                                        </div>
                                        <button onclick="copyProductUrl('${state.formData.productNumber}')" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1.5 rounded-lg transition-colors text-xs whitespace-nowrap">
                                            🔗 商品URLコピー
                                        </button>
                                        ${state.formData.embedProduct ? `
                                            <button onclick="findAndDownloadVideo('${state.formData.productNumber}')" title="[Google Drive > 共有ドライブ > 07_広報 > YouTube > ツイート用動画 > ALL] 内の&quot;${state.formData.productNumber}.mp4&quot;を探してダウンロードします" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1.5 rounded-lg transition-colors text-xs whitespace-nowrap">
                                                ⬇️ 動画DL
                                            </button>
                                        ` : ''}
                                    </div>
                                </div>
                            ` : ''}
                            <div>
                                <div class="bg-gray-50 p-2 rounded-lg rounded-b-none border border-gray-200 border-b-0 whitespace-pre-wrap text-sm leading-relaxed">${state.formData.text || 'テキストなし'}</div>
                                <button onclick="copyToClipboard(\`${state.formData.text}\`)" class="w-full flex items-center justify-center gap-2 bg-gray-200 text-gray-600 py-1.5 rounded-lg rounded-t-none hover:bg-gray-300 transition-colors text-xs border border-gray-200 border-t-0">
                                    📋 テキストをコピー
                                </button>
                            </div>
                            ${state.formData.links && state.formData.links.length > 0 ? `
                                <div>
                                    <div class="space-y-1">
                                        ${state.formData.links.map((link, index) => `
                                            <div class="bg-blue-50 p-2 rounded-lg border border-blue-200 flex items-center gap-2">
                                                <a href="${link}" target="_blank" class="text-blue-600 hover:text-blue-800 text-xs break-all flex-1">🔗 ${link}</a>
                                                <button onclick="copyToClipboard(\`${link}\`)" class="bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded text-xs whitespace-nowrap">
                                                    コピー
                                                </button>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            ${state.formData.remarks ? `
                                <div>
                                    <div class="bg-yellow-50 p-2 rounded-lg border border-yellow-200 text-sm whitespace-pre-wrap">${state.formData.remarks}</div>
                                </div>
                            ` : ''}
                            ${state.formData.images && state.formData.images.length > 0 ? `
                                <div>
                                    <div class="text-xs text-gray-500 mb-1">メディア（${state.formData.images.length}個）</div>
                                    <div class="grid grid-cols-3 gap-2">
                                        ${state.formData.images.map((file, index) => `
                                            <div class="relative group">
                                                ${file.type === 'image' ? `
                                                    <img src="${file.data}" alt="画像 ${index + 1}" class="w-full h-24 object-cover rounded-lg border border-gray-200">
                                                ` : `
                                                    <video src="${file.data}" class="w-full h-24 object-cover rounded-lg border border-gray-200" controls></video>
                                                `}
                                                <button onclick="downloadImage({data: state.formData.images[${index}].data, type: state.formData.images[${index}].type}, \`${state.formData.title || 'media'}\`, ${index})" class="absolute bottom-1 right-1 bg-blue-500 text-white px-2 py-0.5 rounded-lg hover:bg-blue-600 transition-colors shadow-lg text-xs">
                                                    ⬇
                                                </button>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            <div>
                                <div class="flex gap-2 mb-2">
                                    <input type="text" id="checkPersonInput" placeholder="チェック完了した人の名前を入力" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm" onkeypress="if(event.key==='Enter'){addCheckPerson(); event.preventDefault();}">
                                    <button onclick="addCheckPerson()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded-lg transition-colors text-xs">
                                        追加
                                    </button>
                                </div>
                                ${state.formData.checks && state.formData.checks.length > 0 ? `
                                    <div class="flex gap-1 flex-wrap">
                                        ${state.formData.checks.map((person, index) => `
                                            <span class="bg-green-100 text-green-700 px-2 py-1 rounded text-xs inline-flex items-center gap-1 border border-green-300">
                                                ✓ ${person}
                                                <button onclick="removeCheckPerson(${index})" class="text-red-500 hover:text-red-700 font-bold">×</button>
                                            </span>
                                        `).join('')}
                                    </div>
                                ` : '<div class="text-xs text-gray-400">まだチェック完了者はいません</div>'}
                            </div>
                            <div class="flex gap-2 pt-3 border-t">
                                <button onclick="switchToEditMode()" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold transition-colors shadow-md text-sm">
                                    ✏️ 編集
                                </button>
                                <button onclick="confirmDelete('${state.selectedDate}', ${state.editingPostId})" class="bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded-lg font-semibold transition-colors shadow-md text-sm">
                                    🗑
                                </button>
                            </div>
                            ${platforms.includes('x') ? '<div class="pt-2"><button onclick="postToX()" class="w-full bg-black hover:bg-gray-800 text-white py-2 rounded-lg font-semibold transition-colors shadow-md text-sm">𝕏 に投稿</button></div>' : ''}
                            ${platforms.includes('instagram') ? '<div class="pt-2"><button onclick="postToInstagram()" class="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white py-2 rounded-lg font-semibold transition-colors shadow-md text-sm">Instagram に投稿（テスト前）</button></div>' : ''}
                        </div>
                    </div>`;
                } else {
                    editFormHTML = `<div class="bg-blue-50 rounded-2xl shadow-xl p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-bold text-gray-800">${state.editingPostId ? '投稿を編集' : '新規投稿'} - ${state.selectedDate}</h3>
                            <button onclick="cancelEdit(); render();" class="p-1 hover:bg-gray-100 rounded-lg transition-colors">
                                <span class="text-xl">×</span>
                            </button>
                        </div>
                        <div class="space-y-3">
                            ${state.editingPostId ? `
                            <div>
                                <label class="block text-xs font-semibold text-gray-700 mb-1">投稿日</label>
                                <input type="date" value="${state.selectedDate}" onchange="changeSelectedDate(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                            </div>
                            ` : ''}
                            <div>
                                <label class="block text-xs font-semibold text-gray-700 mb-1">投稿タイトル</label>
                                <input type="text" value="${state.formData.title}" onchange="state.formData.title = this.value" placeholder="例: 新商品告知" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-700 mb-1">商品番号</label>
                                <div class="flex gap-2 items-center">
                                    <input type="text" value="${state.formData.productNumber || ''}" onchange="state.formData.productNumber = this.value" placeholder="例: ABC-12345" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                                    <label class="flex items-center gap-1 text-sm whitespace-nowrap">
                                        <input type="checkbox" ${state.formData.embedProduct ? 'checked' : ''} onchange="state.formData.embedProduct = this.checked" class="rounded">
                                        動画埋込
                                    </label>
                                </div>
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-700 mb-1">投稿先SNS（複数選択可）</label>
                                <div class="flex gap-2 flex-wrap">
                                    ${[
                                        {value: 'x', label: '𝕏', color: 'bg-black'},
                                        {value: 'instagram', label: 'IG', color: 'bg-gradient-to-r from-purple-500 to-pink-500'},
                                        {value: 'line', label: 'LINE', color: 'bg-green-500'},
                                        {value: 'stumaga', label: 'スタマガ', color: 'bg-orange-500'},
                                        {value: 'youtube', label: 'YT', color: 'bg-red-600'}
                                    ].map(platform => `
                                        <button onclick="togglePlatform('${platform.value}')" class="py-1.5 px-3 rounded-lg font-semibold text-white transition-all text-xs ${state.formData.platforms.includes(platform.value) ? `${platform.color} ring-2 ring-offset-2 ring-blue-300` : 'bg-gray-300 hover:bg-gray-400'}">
                                            ${platform.label}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-700 mb-1">投稿テキスト</label>
                                <textarea onchange="state.formData.text = this.value" placeholder="投稿する文章を入力..." class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm" rows="4">${state.formData.text}</textarea>
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-700 mb-1">リンク先（最大5つ）</label>
                                ${state.formData.links && state.formData.links.length > 0 ? state.formData.links.map((link, index) => `
                                    <div class="flex gap-2 mb-2">
                                        <input 
                                            type="url" 
                                            value="${link}" 
                                            onchange="state.formData.links[${index}] = this.value" 
                                            placeholder="https://example.com" 
                                            class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                                        >
                                        ${state.formData.links.length > 1 ? `
                                            <button onclick="removeLink(${index})" class="bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded-lg transition-colors text-xs">
                                                ×
                                            </button>
                                        ` : ''}
                                        ${index === state.formData.links.length - 1 && state.formData.links.length < 5 ? `
                                            <button onclick="addLink()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded-lg transition-colors text-xs whitespace-nowrap">
                                                + リンクを追加
                                            </button>
                                        ` : ''}
                                    </div>
                                `).join('') : `
                                    <div class="flex gap-2 mb-2">
                                        <input 
                                            type="url" 
                                            value="" 
                                            onchange="if(!state.formData.links) state.formData.links = []; state.formData.links[0] = this.value" 
                                            placeholder="https://example.com" 
                                            class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                                        >
                                        <button onclick="addLink()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded-lg transition-colors text-xs whitespace-nowrap">
                                            + リンクを追加
                                        </button>
                                    </div>
                                `}
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-700 mb-1">備考</label>
                                <textarea onchange="state.formData.remarks = this.value" placeholder="メモや備考を入力..." class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm" rows="2">${state.formData.remarks || ''}</textarea>
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-700 mb-1">画像（最大20枚）<span class="ml-2 text-xs text-gray-500">${state.formData.images.length} / 20</span></label>
                                <div class="border-2 border-dashed rounded-lg p-3 text-center border-gray-300 hover:border-blue-400">
                                    ${state.formData.images.length > 0 ? `
                                        <div>
                                            <div class="grid grid-cols-3 gap-2 mb-2">
                                                ${state.formData.images.map((image, index) => `
                                                    <div class="relative group">
                                                        ${image.type === 'image' ? `
                                                            <img src="${image.data}" alt="画像 ${index + 1}" class="w-full h-20 object-cover rounded-lg">
                                                        ` : `
                                                            <video src="${image.data}" class="w-full h-20 object-cover rounded-lg" controls></video>
                                                        `}
                                                        <button onclick="removeImage(${index})" class="absolute top-1 right-1 bg-red-500 text-white p-1 rounded-full hover:bg-red-600 transition-colors shadow-lg opacity-0 group-hover:opacity-100 text-xs leading-none w-5 h-5 flex items-center justify-center">
                                                            ×
                                                        </button>
                                                    </div>
                                                `).join('')}
                                            </div>
                                            ${state.formData.images.length < 20 ? `
                                                <label class="inline-block bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded-lg cursor-pointer transition-colors text-xs">
                                                    + さらに追加
                                                    <input type="file" accept="image/*,video/*" multiple onchange="handleImageSelect(event)" class="hidden">
                                                </label>
                                            ` : ''}
                                        </div>
                                    ` : `
                                        <div>
                                            <label class="inline-block bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded-lg cursor-pointer transition-colors text-xs">
                                                📸 画像を選択
                                                <input type="file" accept="image/*,video/*" multiple onchange="handleImageSelect(event)" class="hidden">
                                            </label>
                                        </div>
                                    `}
                                </div>
                            </div>
                            <div class="flex gap-2 pt-2">
                                <button onclick="savePost()" ${state.isSaving ? 'disabled' : ''} class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold transition-colors text-sm ${state.isSaving ? 'opacity-50 cursor-not-allowed' : ''}">
                                    ${state.isSaving ? '⏳ 保存中...' : (state.editingPostId ? '更新' : '保存')}
                                </button>
                            </div>
                        </div>
                    </div>`;
                }
            }

            document.getElementById('app').innerHTML = `
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center gap-3">
                        <h1 class="text-3xl font-bold text-gray-800">📱 SNS投稿カレンダー</h1>
                        <button onclick="exportToSpreadsheet()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-lg transition-colors text-xs flex items-center gap-1">
                            📊 スプレッドシート同期
                        </button>
                    </div>
                    <div class="flex flex-col items-end gap-1">
                        ${state.isSignedIn ? `
                            <div class="flex items-center gap-2">
                                ${state.userName ? `<div class="text-xs text-gray-600">ログイン中: ${state.userName}</div>` : ''}
                                <div class="inline-flex items-center gap-2 bg-green-100 text-green-700 px-3 py-1 rounded-lg text-xs">
                                    ✅ 共有ドライブ接続済
                                </div>
                                <button onclick="handleSignOut()" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded-lg text-xs transition-colors">
                                    ログアウト
                                </button>
                            </div>
                        ` : `
                            <button onclick="handleAuthClick()" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg font-semibold transition-colors shadow-lg text-sm">
                                🔗 Google Driveに接続
                            </button>
                        `}
                        <div class="text-xs text-gray-400">
                            ${state.lastUpdated ? `最終更新: ${formatDateTime(state.lastUpdated)}　` : ''}アプリ更新: ${APP_VERSION}
                        </div>
                    </div>
                </div>
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                    <div class="lg:col-span-2">
                        <div class="bg-white rounded-2xl shadow-xl p-6">
                            <div class="flex items-center justify-between mb-6">
                                <button onclick="changeMonth(-1)" class="p-2 hover:bg-gray-100 rounded-lg transition-colors">
                                    ◀
                                </button>
                                <div class="flex items-center gap-3">
                                    <h2 class="text-2xl font-bold text-gray-800">${monthName}</h2>
                                    <button onclick="goToToday()" class="px-3 py-1 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors">
                                        本日
                                    </button>
                                </div>
                                <button onclick="changeMonth(1)" class="p-2 hover:bg-gray-100 rounded-lg transition-colors">
                                    ▶
                                </button>
                            </div>
                            <div class="grid grid-cols-7 gap-2">
                                ${calendarHTML}
                            </div>
                        </div>
                    </div>
                    <div class="lg:col-span-1">
                        ${editFormHTML || '<div class="bg-gray-50 rounded-2xl shadow-xl p-6 text-center text-gray-500">カレンダーから日付を選択してください</div>'}
                    </div>
                </div>
            `;
        }

        window.addEventListener('load', () => {
            gapiLoaded();
            gisLoaded();
            
            // 30分ごとにトークンの有効性をチェック
            setInterval(async () => {
                if (state.isSignedIn) {
                    await refreshTokenIfNeeded();
                }
            }, 1800000); // 1800000ms = 30分
            
            // 3分ごとに更新をチェック
            setInterval(async () => {
                if (state.isSignedIn && !state.isSaving) {
                    await checkForUpdates();
                }
            }, 180000); // 180000ms = 3分
        });
    </script>
</body>
</html>
